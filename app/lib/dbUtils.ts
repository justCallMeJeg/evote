import { supabase } from './supabaseClient';
import { createHash, createVerify } from 'crypto';

// Define types for your database data
export interface Voter {
    id: number;
    public_key: string;
    name: string;
    group: string;
    verified: boolean;
    voted: boolean;
    created_at: string;
}

export interface Candidate {
    id: number;
    public_key: string;
    name: string;
    position_id: number;
    group: string[];
    verified: boolean;
    created_at: string;
}

export interface Position {
    id: number;
    name: string;
    scope: 'GLOBAL' | 'LOCAL';
    allowed_locals?: string[];
    created_at: string;
}

export interface Election {
    id: number;
    name: string;
    ongoing: boolean;
    finished: boolean;
    created_at: string;
}

export interface Vote {
    id?: number;  // ID is generated by the database
    election_id: number;
    voter_public_key: string;
    candidate_id: number;
    position_id: number;
    department: string;
    timestamp: string;
    signatures: Record<string, string>;
    vote_hash: string;
}

// Utility Functions
export async function getVoter(id: string): Promise<Voter | null> {
    const { data, error } = await supabase
        .from('voters')
        .select('*')
        .eq('id', id)
        .single();

    if (error) {
        console.error('Error fetching voter:', error);
        return null;
    }
    return data ? data as Voter : null;
}

export async function registerVoter(voter: Omit<Voter, 'id' | 'created_at' | 'public_key' | 'verified' | 'voted'>): Promise<Voter | null> {
    const { data, error} = await supabase.from('voters').insert([voter]).select();

    if (error) {
        console.error('Error registering voter:', error.message);
        return null;
    } else {
        console.log('Registering voter:', data);
        return data ? data[0] as Voter : null;
    }
}

export async function getVoters(): Promise<Voter[] | null> {
    const { data, error } = await supabase
        .from('voters')
        .select('*');

    if (error) {
        console.error('Error fetching voters:', error);
        return null;
    }
    return data ? data as Voter[] : null;
}

export async function getCandidate(candidateId: number): Promise<Candidate | null> {
    const { data, error } = await supabase
        .from('candidates')
        .select('*')
        .eq('id', candidateId)
        .single();

    if (error) {
        console.error('Error fetching candidate:', error);
        return null;
    }
    return data ? data as Candidate : null;
}

export async function getCandidates(): Promise<Candidate[] | null> {
    const { data, error } = await supabase
        .from('candidates')
        .select('*');

    if (error) {
        console.error('Error fetching candidates:', error);
        return null;
    }
    return data ? data as Candidate[] : null;
}

export async function getCandidatesByPosition(positionId: number): Promise<Candidate[] | null> {
    const { data, error } = await supabase
        .from('candidates')
        .select('*')
        .eq('position_id', positionId);

    if (error) {
        console.error('Error fetching candidates:', error);
        return null;
    }
    return data ? data as Candidate[] : null;
}

export async function registerCandidate(candidate: Omit<Candidate, 'id' | 'created_at'>, validatorSignature: string, validatorPublicKey: string): Promise<boolean> {
    // Verify validator signature on the candidate data.  We stringify the candidate object
    const candidateDataString = JSON.stringify(candidate);
    const isSignatureValid = await verifySignature(candidateDataString, validatorSignature, validatorPublicKey);

    if (!isSignatureValid) {
        console.error('Invalid validator signature for candidate');
        return false;
    }

    const { data, error } = await supabase
        .from('candidates')
        .insert([candidate]);

    if (error) {
        console.error('Error registering candidate:', error);
        return false;
    }
    return data ? true : false;
}

export async function getPosition(positionId: number): Promise<Position | null> {
    const { data, error } = await supabase
        .from('positions')
        .select('*')
        .eq('id', positionId)
        .single();

    if (error) {
        console.error('Error fetching position:', error);
        return null;
    }
    return data ? data as Position : null;
}

export async function getPositions(): Promise<Position[] | null> {
    const { data, error } = await supabase
        .from('positions')
        .select('*');

    if (error) {
        console.error('Error fetching positions:', error);
        return null;
    }
    return data ? data as Position[] : null;
}

export async function getElection(electionId: number): Promise<Election | null> {
    const { data, error } = await supabase
        .from('elections')
        .select('*')
        .eq('id', electionId)
        .single();

    if (error) {
        console.error('Error fetching election:', error);
        return null;
    }
    return data ? data as Election : null;
}

export async function getElections(): Promise<Election[] | null> {
    const { data, error } = await supabase
        .from('elections')
        .select('*');

    if (error) {
        console.error('Error fetching elections:', error);
        return null;
    }
    return data ? data as Election[] : null;
}

export async function registerVote(vote: Omit<Vote, 'id'>, signatures: Record<string, string>): Promise<Vote | null> {
    const voteHash = hashVote(vote);

    const { data, error } = await supabase.from('votes').insert([{
        election_id: vote.election_id,
        voter_public_key: vote.voter_public_key,
        candidate_id: vote.candidate_id,
        position_id: vote.position_id,
        department: vote.department,
        timestamp: vote.timestamp,
        signatures: signatures,
        vote_hash: voteHash,
    }]);

    if (error) {
        console.error('Error registering vote:', error);
        return null;
    }
    return data ? data[0] as Vote : null;
}

export async function getVotesByElection(electionId: number): Promise<Vote[] | null> {
    const { data, error } = await supabase
        .from('votes')
        .select('*')
        .eq('election_id', electionId);

    if (error) {
        console.error('Error fetching votes:', error);
        return null;
    }
    return data ? data as Vote[] : null;
}

export async function tallyVotes(electionId: number): Promise<Record<number, Record<number, number>> | null> {
    const { data, error } = await supabase
        .from('votes')
        .select('candidate_id, position_id')
        .eq('election_id', electionId);

    if (error) {
        console.error('Error fetching election results:', error);
        return null;
    }

    const tally: Record<number, Record<number, number>> = {};
    (data as { candidate_id: number; position_id: number }[]).forEach(vote => {
        if (!tally[vote.position_id]) {
            tally[vote.position_id] = {};
        }
        if (!tally[vote.position_id][vote.candidate_id]) {
            tally[vote.position_id][vote.candidate_id] = 0;
        }
        tally[vote.position_id][vote.candidate_id]++;
    });
    return tally;
}

function hashVote(voteData: Omit<Vote, 'id' | 'signatures' | 'vote_hash'>): string {
    const combinedString = JSON.stringify(voteData);
    return createHash('sha256').update(combinedString).digest('hex');
}

async function verifySignature(data: string, signature: string, validatorPublicKey: string): Promise<boolean> {
    //  Replace this with your actual signature verification logic.  This is a placeholder!
    try {
        const verify = createVerify('SHA256');
        verify.update(data);
        return verify.verify(validatorPublicKey, signature, 'hex'); // 'hex' encoding
    } catch (error) {
        console.error("Signature verification error:", error);
        return false; // Handle errors during verification
    }
}
